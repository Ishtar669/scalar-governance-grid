import numpy as np

class MacachorState:
    """
    A conceptual class representing a state vector with a scalar component
    and an amplitude vector, analogous to a quantum state.
    """
    def __init__(self, phi_0, phi_vec, orientation):
        # Ensure phi_vec is a numpy array for vector math
        self.scalar = complex(phi_0)
        self.vector = np.array(phi_vec, dtype=complex)
        self.orientation = orientation
        
        # Conceptual normalization check (optional)
        # norm_sq = np.abs(self.scalar)**2 + np.sum(np.abs(self.vector)**2)
        # if not np.isclose(norm_sq, 1.0):
        #     print(f"Warning: State is not normalized (norm^2 = {norm_sq:.4f})")

    def __repr__(self):
        return (f"MacachorState(\n"
                f"  scalar={self.scalar:.3f},\n"
                f"  vector={self.vector},\n"
                f"  orientation='{self.orientation}'\n"
                f")")

    def evolve(self, Hamiltonian, dt):
        """
        Evolves the state using the Macachor evolution operator, 
        analogous to the time evolution in QM (Schrödinger equation).
        
        The evolution operator U is approximated by U ≈ I - i * H * dt / h_bar.
        """
        # The full state vector psi is conceptually [self.scalar, *self.vector]
        # For simplicity, assume the 'Hamiltonian' is an (N+1)x(N+1) matrix 
        # that operates on the combined state space.
        
        h_bar = 1.0 # Set h_bar to 1 for simplified unitless calculation
        
        # 1. Construct the total state vector |psi>
        psi = np.array([self.scalar] + self.vector.tolist(), dtype=complex)
        
        # 2. Approximate the Evolution Operator U
        N_total = len(psi)
        Identity = np.identity(N_total, dtype=complex)
        Evolution_Operator = Identity - 1j * Hamiltonian * dt / h_bar
        
        # 3. Apply the operator: |psi(t+dt)> = U |psi(t)>
        psi_new = np.dot(Evolution_Operator, psi)
        
        # 4. Update the state's components
        self.scalar = psi_new[0]
        self.vector = psi_new[1:]
        
        # Note: In real QM, the evolution operator U is typically U = exp(-i * H * t / h_bar)
        # This implementation uses the first-order Taylor approximation for simplicity.

    def measure(self, operator):
        """
        Performs a conceptual measurement, analogous to applying a 
        Hermitian operator in QM to get an expectation value.
        
        The expectation value is <O> = <psi| Operator |psi>.
        """
        # 1. Construct the total state vector |psi>
        psi = np.array([self.scalar] + self.vector.tolist(), dtype=complex)
        
        # 2. Calculate the expectation value <O> = <psi| Operator |psi>
        # This is equivalent to psi_dagger * Operator * psi
        # psi_dagger is the conjugate transpose of psi
        psi_dagger = np.conj(psi)
        
        # Calculate (Operator * |psi>)
        op_psi = np.dot(operator, psi)
        
        # Calculate <psi| * (Operator |psi>)
        expectation_value = np.dot(psi_dagger, op_psi)
        
        # Since <O> must be real for a Hermitian operator, we take the real part
        # Note: A measurement in QM typically involves collapsing the state, 
        # which is not included in this simple expectation value calculation.
        
        print(f"Measurement performed in orientation: {self.orientation}")
        return expectation_value.real
